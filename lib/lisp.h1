/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * HLG 
 */


/* This is a just an array pointer, that contains some basic lisp functions
 * It would be load using mmap at startup, unless -b flag is specified 
 * Your are able to put any function you want, just be sure that the function 
 * works :). You could also obey the format:
 * "(defun fact(n)
 *     (cond ((= n 0) 1)
 *      (t
 *       (* (fact (- n 1)) n))))\n"
 */

char *s[] = {
	"(defun first (x) (car x))\n",
	"(defun second (x) (car (cdr x)))\n",
	"(defun third (x) (car (cdr (cdr x))))\n",
	"(defun caar (x) (car (car x)))\n",
	"(defun cadr (x) (car (cdr x)))\n",
	"(defun cdar (x) (cdr (car x)))\n",
	"(defun cddr (x) (cdr (cdr x)))\n",
	"(defun caaar (x) (car (car (car x))))\n",
	"(defun caadr (x) (car (car (cdr x))))\n",
	"(defun cadar (x) (car (cdr (car x))))\n",
	"(defun caddr (x) (car (cdr (cdr x))))\n",
	"(defun cdaar (x) (cdr (car (car x))))\n",
	"(defun cdadr (x) (cdr (car (cdr x))))\n",
	"(defun cddar (x) (cdr (cdr (car x))))\n",
	"(defun cdddr (x) (cdr (cdr (cdr x))))\n",
	"(defun last* (l)\n",
	"  (cond ((eq (cdr l) nil) (car l))\n",
	"	(t (last* (cdr l)))))\n",
	"(defun cond* (x)\n",
	"  (cond ((set 'cond-r (eval (caar x)))\n",
	"	 (cond ((cdar x) (progn* (cdar x)))\n",
	"	       (t cond-r)))\n",
	"	((cdr x) (cond* (cdr x)))\n",
	"	(t nil)))\n",
	"(defun butlast(l)\n",
	"  (cond ((eq (cdr l) nil) nil)\n",
	"        (t (cons (car l) (butlast (cdr l))))))\n",
	"(defun union (a b)\n",
	"    (cond ((null a) b)\n",
	"		 ((null b) a)\n",
	"        ((member (car a) b) (union (cdr a) b))\n",
	"        (t (cons (car a) (union (cdr a) b)))))\n",
	"(defun get-names(x)\n",
	"    (cond ((eq x nil) nil)",
	"           (t (cons (caar x) (get-names (cdr x))))))\n",	
	"(defun get-values(x)\n",
	"    (cond ((eq x nil) nil)",
	"           (t (cons (cadar x) (get-values (cdr x))))))\n",	
	"(defun unpair(x)\n",
	"    (list (get-names x) (get-values x)))\n",
	"(defun intersection (a b)\n",
	"    (cond ((null a) nil)\n",
	"        ((member (car a) b)\n",
	"            (cons (car a) (intersection (cdr a) b)))\n",
	"        (t (intersection (cdr a) b))))\n",
	"(defun progn* (x)\n",
	"    (cond ((cdr x) (eval (car x)) (progn* (cdr x)))\n",
	"	  (t (eval (car x)))))\n",
	"(defun subst (new old l)\n",
	"  (cond ((atom l) (cond ((eq l old) new) (t l)))\n",
	"	(t (cons (subst new old (car l))\n",
	"		 (subst new old (cdr l))))))\n",
	"(defun subst* (as l)\n",
	"   (cond ((eq as nil) l)\n",
	"         (t (subst* (cdr as)\n",
	"                (subst (car (car as)) (car (cdr (car as)))\n",
	"          l)))))\n",
	"(defun equal* (x y)\n",
	"  (or (and (atom x) (atom y) (eq x y))\n",
	"      (and (not (atom x))\n",
	"	   (not (atom y))\n",
	"	   (equal (car x) (car y))\n",
	"	   (equal (cdr x) (cdr y)))))\n",
	"(defun eval-f-by-subst (f args)\n",
	"   (eval (subst* (pair* args (car (cdr f))) (car (cdr (cdr f))))))\n",
	"(defun eval-by-subst(as expr)\n",
	"      (eval (subst* as expr)))\n",
	"(defun append (x y)\n",
	"  (cond ((null x) y)\n",
	"	(t (cons (car x) (append (cdr x) y)))))\n",
	"(defun among (x y)\n",
	"  (and (not (null y))\n",
	"       (or (equal x (car y)) (among x (cdr y)))))\n",
	"(defun assoc (x y)\n",
	"  (cond ((null y) nil)\n",
	"	((eq (caar y) x) (car y))\n",
	"		(t (assoc x (cdr y)))))\n",
	"(defun rplaca (x y)\n",
	"  (cons y (cdr x)))\n",
	"(defun rplacd (x y)\n",
	"  (cons (car x) y))\n",
	"(defun alt(x)\n",
	"  (cond ((or (null x)\n",
	"	      (null (cdr x))) x)\n"
	"	 (t (cons (car x) (alt (cddr x))))))\n",
	"(defun assoc* (x y)\n",
	"   (cond ((eq (caar y) x) (cadar y))\n",
	"	  ((eq y nil) nil)\n",
	"      (t (assoc* x (cdr y)))))\n",
	"(defun try-substs (substitutes x)\n",
	"  (cond ((null substitutes) x)\n",
    "    ((eq x (caar substitutes)) (cdar substitutes))\n",
   	"     (t (try-substs (cdr substitutes) x))))\n",
	"(defun atom-sublis (substitutes pattern)\n",
	"  (cond ((null pattern) nil)\n",
	"       ((atom pattern) (try-substs substitutes pattern))\n",
	"        (t (cons\n",
    "     		(atom-sublis substitutes (car pattern))\n",
    "     		(atom-sublis substitutes (cdr pattern))))))\n",
	"(defun sublis (x y)\n",
	"  (cond ((atom y) (_sublis x y))\n",
	"	(t (cons (sublis x (car y)) (sublis x (cdr y))))))\n",
	"(defun _sublis (x z)\n",
	"  (cond ((null x) z)\n",
	"	((eq (caar x) z) (cadar x))\n",
	"	(t (_sublis (cdr x) z))))\n",
	"(defun remove (e l)\n",
	"  (cond ((null l) nil)\n",
	"	((equal e (car l)) (remove e (cdr l)))\n",
	"	(t (cons (car l) (remove e (cdr l))))))\n",
	"(defun succ (x y)\n",
	"  (cond ((or (null y) (null (cdr y))) nil)\n",
	"	((eq (car y) x) (cadr y))\n",
	"	(t (succ x (cdr y)))))\n",
	"(defun pred (x y)\n",
	"  (cond ((or (null y) (null (cdr y))) nil)\n",
	"	((eq (cadr y) x) (car y))\n",
	"	(t (pred x (cdr y)))))\n",
	"(defun before (x y)\n",
	"  (cond ((atom x) nil)\n",
	"	((null (cdr x)) nil)\n",
	"	((equal (car x) y) nil)\n",
	"	((equal (cadr x) y) (cons (car x) nil))\n",
	"	(t (cons (car x) (before (cdr x) y)))))\n",
	"(defun after (x y)\n",
	"  (cond ((atom x) nil)\n",
	"	((equal (car x) y) (cdr x))\n",
	"	(t (after (cdr x) y))))\n",
	"(defun ldifference (in out)\n",
	"  (cond ((null in) nil)\n",
	"	((member (car in) out) (ldifference (cdr in) out))\n",
	"	(t (cons (car in) (ldifference (cdr in) out)))))\n",
	"(defun subsetp (a b)\n",
	"  (cond ((null a) t)\n",
	"	((member (car a) b) (subsetp (cdr a) b))\n",
	"	(t nil)))\n",
	"(defun samesetp (a b)\n",
	"	(and (subsetp a b) (subsetp b a)))\n",
	"(defun apply (f exp)\n",
	"   (cond ((null exp) nil)\n",
	"         (t (eval (cons f exp)))))\n",
	"(defun maplist (exp f)\n",
	"   (cond ((null exp) nil)\n",
	"         (t (cons (apply f exp)\n",
	"            (maplist (cdr exp) f)))))\n",
	"(defun mapcar (op a b)\n",
	"  (eval (append (list op) (append a b))))\n",
	"(defun flatten (s-expression)\n",
	"	(if (atom s-expression)\n",
	"		s-expression\n",
	"		(flatten-aux s-expression)))\n",
	"(defun reverse (l)\n",
	"(labels ((rev1 (l rev-so-far)\n",
	"(if (null l) rev-so-far\n",
	"(rev1\n",
	"(cdr l)\n",
	"(cons (car l) rev-so-far)))))\n",
	"(rev1 l nil)))\n",
	"(defun flatten-aux (somelist)\n",
	"	(if (listp (car somelist))\n",
	"		(append (flatten (car somelist)) (flatten (cdr somelist)))\n",
	"		(cons (car somelist) (flatten (cdr somelist)))))\n",
	"(setq ___END___ \"___END___\")\n"
};
